{"ast":null,"code":"/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.2): util/scrollBar.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nimport SelectorEngine from '../dom/selector-engine';\nimport Manipulator from '../dom/manipulator';\nimport { isElement } from './index';\nconst SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\nconst SELECTOR_STICKY_CONTENT = '.sticky-top';\n\nclass ScrollBarHelper {\n  constructor() {\n    this._element = document.body;\n  }\n\n  getWidth() {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n    const documentWidth = document.documentElement.clientWidth;\n    return Math.abs(window.innerWidth - documentWidth);\n  }\n\n  hide() {\n    const width = this.getWidth();\n\n    this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width\n\n\n    this._setElementAttributes(this._element, 'paddingRight', calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n\n\n    this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', calculatedValue => calculatedValue + width);\n\n    this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', calculatedValue => calculatedValue - width);\n  }\n\n  _disableOverFlow() {\n    this._saveInitialAttribute(this._element, 'overflow');\n\n    this._element.style.overflow = 'hidden';\n  }\n\n  _setElementAttributes(selector, styleProp, callback) {\n    const scrollbarWidth = this.getWidth();\n\n    const manipulationCallBack = element => {\n      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n        return;\n      }\n\n      this._saveInitialAttribute(element, styleProp);\n\n      const calculatedValue = window.getComputedStyle(element)[styleProp];\n      element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;\n    };\n\n    this._applyManipulationCallback(selector, manipulationCallBack);\n  }\n\n  reset() {\n    this._resetElementAttributes(this._element, 'overflow');\n\n    this._resetElementAttributes(this._element, 'paddingRight');\n\n    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');\n\n    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');\n  }\n\n  _saveInitialAttribute(element, styleProp) {\n    const actualValue = element.style[styleProp];\n\n    if (actualValue) {\n      Manipulator.setDataAttribute(element, styleProp, actualValue);\n    }\n  }\n\n  _resetElementAttributes(selector, styleProp) {\n    const manipulationCallBack = element => {\n      const value = Manipulator.getDataAttribute(element, styleProp);\n\n      if (typeof value === 'undefined') {\n        element.style.removeProperty(styleProp);\n      } else {\n        Manipulator.removeDataAttribute(element, styleProp);\n        element.style[styleProp] = value;\n      }\n    };\n\n    this._applyManipulationCallback(selector, manipulationCallBack);\n  }\n\n  _applyManipulationCallback(selector, callBack) {\n    if (isElement(selector)) {\n      callBack(selector);\n    } else {\n      SelectorEngine.find(selector, this._element).forEach(callBack);\n    }\n  }\n\n  isOverflowing() {\n    return this.getWidth() > 0;\n  }\n\n}\n\nexport default ScrollBarHelper;","map":{"version":3,"sources":["E:/VSCode Files/Making-React-App/IndustrialProject/ShrishtiSaxena/G2B7_ReactJS_GradedProject4-main/client/node_modules/bootstrap/js/src/util/scrollbar.js"],"names":["SelectorEngine","Manipulator","isElement","SELECTOR_FIXED_CONTENT","SELECTOR_STICKY_CONTENT","ScrollBarHelper","constructor","_element","document","body","getWidth","documentWidth","documentElement","clientWidth","Math","abs","window","innerWidth","hide","width","_disableOverFlow","_setElementAttributes","calculatedValue","_saveInitialAttribute","style","overflow","selector","styleProp","callback","scrollbarWidth","manipulationCallBack","element","getComputedStyle","Number","parseFloat","_applyManipulationCallback","reset","_resetElementAttributes","actualValue","setDataAttribute","value","getDataAttribute","removeProperty","removeDataAttribute","callBack","find","forEach","isOverflowing"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,cAAP,MAA2B,wBAA3B;AACA,OAAOC,WAAP,MAAwB,oBAAxB;AACA,SAASC,SAAT,QAA0B,SAA1B;AAEA,MAAMC,sBAAsB,GAAG,mDAA/B;AACA,MAAMC,uBAAuB,GAAG,aAAhC;;AAEA,MAAMC,eAAN,CAAsB;AACpBC,EAAAA,WAAW,GAAG;AACZ,SAAKC,QAAL,GAAgBC,QAAQ,CAACC,IAAzB;AACD;;AAEDC,EAAAA,QAAQ,GAAG;AACT;AACA,UAAMC,aAAa,GAAGH,QAAQ,CAACI,eAAT,CAAyBC,WAA/C;AACA,WAAOC,IAAI,CAACC,GAAL,CAASC,MAAM,CAACC,UAAP,GAAoBN,aAA7B,CAAP;AACD;;AAEDO,EAAAA,IAAI,GAAG;AACL,UAAMC,KAAK,GAAG,KAAKT,QAAL,EAAd;;AACA,SAAKU,gBAAL,GAFK,CAGL;;;AACA,SAAKC,qBAAL,CAA2B,KAAKd,QAAhC,EAA0C,cAA1C,EAA0De,eAAe,IAAIA,eAAe,GAAGH,KAA/F,EAJK,CAKL;;;AACA,SAAKE,qBAAL,CAA2BlB,sBAA3B,EAAmD,cAAnD,EAAmEmB,eAAe,IAAIA,eAAe,GAAGH,KAAxG;;AACA,SAAKE,qBAAL,CAA2BjB,uBAA3B,EAAoD,aAApD,EAAmEkB,eAAe,IAAIA,eAAe,GAAGH,KAAxG;AACD;;AAEDC,EAAAA,gBAAgB,GAAG;AACjB,SAAKG,qBAAL,CAA2B,KAAKhB,QAAhC,EAA0C,UAA1C;;AACA,SAAKA,QAAL,CAAciB,KAAd,CAAoBC,QAApB,GAA+B,QAA/B;AACD;;AAEDJ,EAAAA,qBAAqB,CAACK,QAAD,EAAWC,SAAX,EAAsBC,QAAtB,EAAgC;AACnD,UAAMC,cAAc,GAAG,KAAKnB,QAAL,EAAvB;;AACA,UAAMoB,oBAAoB,GAAGC,OAAO,IAAI;AACtC,UAAIA,OAAO,KAAK,KAAKxB,QAAjB,IAA6BS,MAAM,CAACC,UAAP,GAAoBc,OAAO,CAAClB,WAAR,GAAsBgB,cAA3E,EAA2F;AACzF;AACD;;AAED,WAAKN,qBAAL,CAA2BQ,OAA3B,EAAoCJ,SAApC;;AACA,YAAML,eAAe,GAAGN,MAAM,CAACgB,gBAAP,CAAwBD,OAAxB,EAAiCJ,SAAjC,CAAxB;AACAI,MAAAA,OAAO,CAACP,KAAR,CAAcG,SAAd,IAA4B,GAAEC,QAAQ,CAACK,MAAM,CAACC,UAAP,CAAkBZ,eAAlB,CAAD,CAAqC,IAA3E;AACD,KARD;;AAUA,SAAKa,0BAAL,CAAgCT,QAAhC,EAA0CI,oBAA1C;AACD;;AAEDM,EAAAA,KAAK,GAAG;AACN,SAAKC,uBAAL,CAA6B,KAAK9B,QAAlC,EAA4C,UAA5C;;AACA,SAAK8B,uBAAL,CAA6B,KAAK9B,QAAlC,EAA4C,cAA5C;;AACA,SAAK8B,uBAAL,CAA6BlC,sBAA7B,EAAqD,cAArD;;AACA,SAAKkC,uBAAL,CAA6BjC,uBAA7B,EAAsD,aAAtD;AACD;;AAEDmB,EAAAA,qBAAqB,CAACQ,OAAD,EAAUJ,SAAV,EAAqB;AACxC,UAAMW,WAAW,GAAGP,OAAO,CAACP,KAAR,CAAcG,SAAd,CAApB;;AACA,QAAIW,WAAJ,EAAiB;AACfrC,MAAAA,WAAW,CAACsC,gBAAZ,CAA6BR,OAA7B,EAAsCJ,SAAtC,EAAiDW,WAAjD;AACD;AACF;;AAEDD,EAAAA,uBAAuB,CAACX,QAAD,EAAWC,SAAX,EAAsB;AAC3C,UAAMG,oBAAoB,GAAGC,OAAO,IAAI;AACtC,YAAMS,KAAK,GAAGvC,WAAW,CAACwC,gBAAZ,CAA6BV,OAA7B,EAAsCJ,SAAtC,CAAd;;AACA,UAAI,OAAOa,KAAP,KAAiB,WAArB,EAAkC;AAChCT,QAAAA,OAAO,CAACP,KAAR,CAAckB,cAAd,CAA6Bf,SAA7B;AACD,OAFD,MAEO;AACL1B,QAAAA,WAAW,CAAC0C,mBAAZ,CAAgCZ,OAAhC,EAAyCJ,SAAzC;AACAI,QAAAA,OAAO,CAACP,KAAR,CAAcG,SAAd,IAA2Ba,KAA3B;AACD;AACF,KARD;;AAUA,SAAKL,0BAAL,CAAgCT,QAAhC,EAA0CI,oBAA1C;AACD;;AAEDK,EAAAA,0BAA0B,CAACT,QAAD,EAAWkB,QAAX,EAAqB;AAC7C,QAAI1C,SAAS,CAACwB,QAAD,CAAb,EAAyB;AACvBkB,MAAAA,QAAQ,CAAClB,QAAD,CAAR;AACD,KAFD,MAEO;AACL1B,MAAAA,cAAc,CAAC6C,IAAf,CAAoBnB,QAApB,EAA8B,KAAKnB,QAAnC,EAA6CuC,OAA7C,CAAqDF,QAArD;AACD;AACF;;AAEDG,EAAAA,aAAa,GAAG;AACd,WAAO,KAAKrC,QAAL,KAAkB,CAAzB;AACD;;AA/EmB;;AAkFtB,eAAeL,eAAf","sourcesContent":["/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.2): util/scrollBar.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nimport SelectorEngine from '../dom/selector-engine'\nimport Manipulator from '../dom/manipulator'\nimport { isElement } from './index'\n\nconst SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'\nconst SELECTOR_STICKY_CONTENT = '.sticky-top'\n\nclass ScrollBarHelper {\n  constructor() {\n    this._element = document.body\n  }\n\n  getWidth() {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n    const documentWidth = document.documentElement.clientWidth\n    return Math.abs(window.innerWidth - documentWidth)\n  }\n\n  hide() {\n    const width = this.getWidth()\n    this._disableOverFlow()\n    // give padding to element to balance the hidden scrollbar width\n    this._setElementAttributes(this._element, 'paddingRight', calculatedValue => calculatedValue + width)\n    // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n    this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', calculatedValue => calculatedValue + width)\n    this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', calculatedValue => calculatedValue - width)\n  }\n\n  _disableOverFlow() {\n    this._saveInitialAttribute(this._element, 'overflow')\n    this._element.style.overflow = 'hidden'\n  }\n\n  _setElementAttributes(selector, styleProp, callback) {\n    const scrollbarWidth = this.getWidth()\n    const manipulationCallBack = element => {\n      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n        return\n      }\n\n      this._saveInitialAttribute(element, styleProp)\n      const calculatedValue = window.getComputedStyle(element)[styleProp]\n      element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`\n    }\n\n    this._applyManipulationCallback(selector, manipulationCallBack)\n  }\n\n  reset() {\n    this._resetElementAttributes(this._element, 'overflow')\n    this._resetElementAttributes(this._element, 'paddingRight')\n    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight')\n    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight')\n  }\n\n  _saveInitialAttribute(element, styleProp) {\n    const actualValue = element.style[styleProp]\n    if (actualValue) {\n      Manipulator.setDataAttribute(element, styleProp, actualValue)\n    }\n  }\n\n  _resetElementAttributes(selector, styleProp) {\n    const manipulationCallBack = element => {\n      const value = Manipulator.getDataAttribute(element, styleProp)\n      if (typeof value === 'undefined') {\n        element.style.removeProperty(styleProp)\n      } else {\n        Manipulator.removeDataAttribute(element, styleProp)\n        element.style[styleProp] = value\n      }\n    }\n\n    this._applyManipulationCallback(selector, manipulationCallBack)\n  }\n\n  _applyManipulationCallback(selector, callBack) {\n    if (isElement(selector)) {\n      callBack(selector)\n    } else {\n      SelectorEngine.find(selector, this._element).forEach(callBack)\n    }\n  }\n\n  isOverflowing() {\n    return this.getWidth() > 0\n  }\n}\n\nexport default ScrollBarHelper\n"]},"metadata":{},"sourceType":"module"}